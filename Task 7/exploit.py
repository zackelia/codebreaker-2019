import argparse
import base64
import binascii
import hashlib
import os

from Crypto.PublicKey import RSA


r_keys = {
    "256": [
        "pTo199138gu60LE4sX/pjMnQ5l3LIQ1acv7229NLz3M=",
        "uR3vgJADCGRzjjD83RJACtktZed7gkeU7VUa6wGNwlU="
    ],
    "512": [
        "nZC6sIqXhjcIDtNgOmDMZMaCnYIj3obAvCU7u9uZEcOW9zhvZlSRSiR4BKkudAnIb4rtPCSs9rb8hTaTpZQWwQ==",
        "ypSGX62TaKsVL3/9OMWdbvDlkc/Shm5IYbotRGOyx8xuoU8fjTv6grPAi5BEe+xiBRDFTlFPIMEZPpaZ+z/SBQ=="
    ],
    "1024": [
        "KR6tXlSIS17fgeJFIsHWRFiuChSy3Nunk1f2kV0QXH7StBRb2NtDqZUesPIttLzFkH+fsImW2JwX3DBaVfvHYTy6Chpv85sCEQLt15NEnJhLuPZb0ACcO8LMspcwODMklYoGEncZYiwMOy5ogApb0QAxkKVZvUJg7+TE0J/KlHc=",
        "mqHamGlJxHeYfje5sJAKp3goHpJZFGOeWFKZrRL5LcjiN4oWkCcaSM3LZ/Sz+DZLk1Y/w5NJzd2bxRPRtIscmoymE8LEhslX9ADZX4wdZd/VTXkMqOvngKiyOTM7ajA5ZdK0uKywFppPguprzFie4/oziD54c9kKyXVvjIHqHe0="
    ]
}


def mod_inverse(e, phi):
    """Calculate the modular multiplicative inverse of e mod Î»(n)."""
    a, b, u = 0, phi, 1
    while e > 0:
        q = b // e
        e, a, b, u = b % e, u, e, a - q * u
    return a % phi


def permute_r_key(r1):
    """Permutes r1 based on its size. In my testing, however, only 1024 bit r keys are ever permuted."""
    r1 = hex(r1)[2:].encode()

    if len(r1) == 64:
        r1 = hashlib.sha256(r1).hexdigest()
    if len(r1) == 128:
        r1 = hashlib.sha512(r1).hexdigest()
    if len(r1) == 256:
        r1 = hashlib.sha512(r1).hexdigest()
        r1 += hashlib.sha512(r1.encode()).hexdigest()
    
    return int(r1, 16)


def export_private_key(p, q, name):
    """Calculate a private key from two primes and save it as a .pem file."""
    n = p * q
    e = 65537
    phi = (p - 1) * (q - 1)
    d = mod_inverse(e, phi)

    params = (n, e, d, p, q)
    key = RSA.construct(params)

    with open(f"{name}.priv", "wb") as file:
        file.write(key.exportKey())


def calculate_private_key(name, bits):
    """Calculate a private key from a vulnerable public key using TerrorTime alg1."""

    # Check if public keys have been extracted from the keygen or from servers
    if not os.path.exists(f"{name}.pub"):
        raise IOError(f"{name}.pub does not exist. Extract from keygen or servers.")

    # Check if the smaller private key exists, recursively calculate smaller keys
    if not os.path.exists(f"{bits//2}.priv"):
        if bits == 256:
            raise IOError("256.priv does not exist. Calculate using Yafu.")
        calculate_private_key(str(bits//2), bits//2)
    
    with open(f"{name}.pub", "rb") as file:
        pub = RSA.importKey(file.read())
     
    with open(f"{bits//2}.priv", "rb") as file:
        priv = RSA.importKey(file.read())

    r1 = int(binascii.hexlify(base64.b64decode(r_keys[f"{bits//2}"][0])), 16)
    r2 = int(binascii.hexlify(base64.b64decode(r_keys[f"{bits//2}"][1])), 16)

    for i in range(1000):
        # Get first half of number, discarding the random bytes
        half = pub.n >> bits // 2
        encrypted = half ^ (r2 + i)
        decrypted = priv.decrypt(encrypted)

        # Keep a copy of r1 in case it has to be permuted
        r1_copy = r1

        for _ in range(10):
            for j in range(10):
                result = decrypted ^ (r1_copy + j)

                # If we have a divisor of n, we can calcuate the private key
                if pub.n % result == 0:
                    p = result
                    q = pub.n // p
                    export_private_key(p, q, name)
                    return

            r1_copy = permute_r_key(r1_copy)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("name", help="the name of the key")
    args = parser.parse_args()

    calculate_private_key(args.name, 2048)
